## first step

- リストがソートされているので、2つの要素を比べて重複があれば前ノードが現ノードを通り越した先を指すようにすることを思いついた

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None or head.next is None:
            return head
        
        prev_node = head
        curr_node = head.next
        while curr_node:
            if prev_node.val == curr_node.val:
                prev_node.next = curr_node.next
            else:
                prev_node = curr_node
            curr_node = curr_node.next
        return head
```

## second step

- `if head.next is None`はいらない。

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None:
            return head

        prev_node = head
        curr_node = head.next
        while curr_node:
            if prev_node.val == curr_node.val:
                prev_node.next = curr_node.next
            else:
                prev_node = curr_node
            curr_node = curr_node.next
        return head
```

## third step

- 他の人のコードを読んで、以下の書き方が一番しっくりきた

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = head

        while node:
            while node.next and node.val == node.next.val:
                node.next = node.next.next
            node = node.next
        return head
```

- 読んだコード
  - https://github.com/yus-yus/leetcode/pull/3/files
  - https://github.com/ichika0615/arai60/pull/3/files
