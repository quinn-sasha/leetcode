## First step

- treeには慣れていないので、少しどうするか悩んだ。図を書いたら、わかりやすくなった。
- 再帰で処理を抽象化できる。
- Maximu depth: 1(現在のノード) + max(左の部分木のノード数、右の部分木のノード数)

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        max_depth = 0
        
        if root:
            max_depth = max(self.maxDepth(root.left), self.maxDepth(root.right))
            max_depth += 1
        return max_depth
```


## Second step

- 考え方は最初と同じ。
- 早期リターンした方がわかりやすいと考えた。
- `max_depth`という変数は使わずに、ルートの有無によって返すものを変えている。

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
```


## 振り返り

- 自分の最初のコードDFSと呼ばれているのは知らなかった。DFSとBFSについてあまりわかっていないので、いつか調べよう。
- 最後のreturn文が少し長いから、`left_depth`や`right_depth`のような変数に置き換えてもいい。
- 反復の処理はBFSみたいで、書くのが難しいかなと思っていたけど、答えを見たらシンプルだった。
- 再帰を使っているので、空間計算量が最悪O(n)になることに気をつける。


## Third step


- 3つの解法で解いてみたが、最初の再帰が一番しっくりくる。

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        left_height = self.maxDepth(root.left)
        right_height = self.maxDepth(root.right)
        return max(left_height, right_height) + 1
```


- 反復の方が安心感があると思ったので、何回も書いた。


```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0     
        max_depth = 0
        current_nodes = [root]
        while current_nodes:
            next_nodes = []
            for node in current_nodes:
                if node.left:
                    next_nodes.append(node.left)
                if node.right:
                    next_nodes.append(node.right)
            current_nodes = next_nodes
            max_depth += 1
        return max_depth
```

## 次やること

- 本でtreeデータ構造の章を読む。
