## first step

- `nums1`と`nums2`を`set`にして、両者の共通部分を返すと思った。
- `set`のメソッドで、共通部分を求めることができそう。[ここ](https://docs.python.org/ja/3.13/library/stdtypes.html#frozenset.intersection)にあった。

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        intersection = []
        unique_nums1 = set(nums1)
        unique_nums2 = set(nums2)

        for num1 in unique_nums1:
            if num1 in unique_nums2:
                intersection.append(num1)
        return intersection
```

## second step

- `&`オペレーターを使って共通部分を求めた

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        intersection = []
        unique_nums1 = set(nums1)
        unique_nums2 = set(nums2)

        return list(unique_nums1 & unique_nums2)
```

## 振り返り

- 最初の解法で、より要素数の少ない方のセットを走査した方が効率が良さそう。短いコードだから、複雑にはならないだろう。
- Two pointersも使える。マージソートのマージに似てる。
- `counting sort`みたいな解法は思いつかなかった。面白い。
- 辞書を使うなら、実際のカウント数ではなくて0か1のみにした方がいい。カウント数に意味がある、と読む人に思わせるかもしれない。


## third step

- `counting sort`の解法
- 必要な要素数をもつ入れ物（配列）を用意する。
- `nums1`を見ていき、出現した整数を入れ物の位置としてとり、1を代入する。最終的にセットと同じようなデータを持つ。
- `nums2`を見ていき、すでに同じ要素が現れていたら答えに加える。

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nbuckets = 1001
        seen = [0] * nbuckets
        common = []

        for n1 in nums1:
            seen[n1] = 1
        for n2 in nums2:
            if seen[n2]:
                common.append(n2)
                seen[n2] = 0
        return common
```

- もう一度セットの解法
- `set.intersection()`の実装みたいに、小さいセットの方を捜査するようにした。こっちの方がいいと思う。

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        common = []
        smaller = set(nums1)
        bigger = set(nums2)

        if len(smaller) > len(bigger):
            smaller, bigger = bigger, smaller
        for num in smaller:
            if num in bigger:
                common.append(num)
        return list(common)
```

- 問題を見た時に連想する幅がまだ狭いことを実感した。


## Step4（解き直し）

- Third stepと同じようなコードを書いた。

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
	"""
	Allowed input range for these input lists: 0 <= range <= 1000
	"""
        common = []
        max_elements = 1001
        seen = [0] * max_elements

        for n1 in nums1:
            seen[n1] = 1
        for n2 in nums2:
            if seen[n2] == 1:
                common.append(n2)
                seen[n2] = 0
        return common
```


## 調べたこと

- [Set time complexity](https://wiki.python.org/moin/TimeComplexity#set)
- [`&`演算子](https://github.com/python/cpython/blob/0654336dd5138aec04e3017e15ccbb90a44e053d/Lib/_collections_abc.py#L622)
- [cpythonのintersection実装](https://github.com/python/cpython/blob/main/Objects/setobject.c#L1362)
	- 2つの入力セットをA, Bとする。
	- もし両方のセットが同じ要素を持つなら、片方のコピーを返す
	- スワップすることで必ずAの要素数がB以上になる
	- Bを走査していって、その要素（key）がAに含まれるなら、新たに用意したセットCに加える
	- 共通要素を持つセットCを返す
