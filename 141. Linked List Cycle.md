## first step

- 今まで訪れたノードのポインターを`set`に保存しておく方法が頭に浮かんだ
- なぜセットだと要素が含まれているかいないかの判定が早くなるかはわかっていない

```python
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        visited_nodes = set()

        while head:
            if head in visited_nodes:
                return True
            visited_nodes.add(head)
            head = head.next
        return False
```

## second step

- `visited_nodes`と明確にnodesを入れない方が自然な気がする

```python
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        visited = set()

        while head:
            if head in visited:
                return True
            visited.add(head)
            head = head.next
        return False
```

## third step

- 他の人の解答を見て、フロイドのアルゴリズムについて知った
- 最初はslowとfastがサイクルがあっても合流しない可能性があると思ったが、両者の距離は1歩づつ縮まるから必ず合流することを知った

```python
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        slow = fast = head

        while (fast and fast.next):
            slow = slow.next
            fast = fast.next.next
            if (slow == fast):
                return True
        return False
```


- 参考に読んだコード: https://github.com/hayashi-ay/leetcode/pull/15
- [document about set](https://docs.python.org/ja/3/library/stdtypes.html#set)
	- `set`データ構造はhash tableを利用しているらしい
	- x in setという処理の場合、xのハッシュ値が計算される
	- hash table内で何かしらのハッシュ値の検索がされるらしいが、それが辞書での検索のように$O(1)$らしい
- [source code cpython](https://github.com/python/cpython/blob/main/Objects/setobject.c)
	- 難しくて理解できなかった。本でデータ構造の章を読んだらまた戻ってくるかも
