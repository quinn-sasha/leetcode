## first step

- 最終的に返すノードをどうすればいいか悩んだ
- 15分を超えていたので提出したが、動かなかった
- 思いついた方法：
	- 重複値を変数に保存し、その変数と同じ値を持つノードを削除する
	- 同じ値を持つ2つのノードを、両者とも同時に削除する。このやり方では奇数個の重複ノードに対応できないので間違えた。

（動かない）
```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = ListNode()
        node.val = None
        node.next = head

        while node.next:
            while node.next.next and node.next.val == node.next.next.val:
                node.next = node.next.next.next
            node = node.next
        return head
```

- 混乱していたので、一度紙に書いて整理した
- `head`より一つ前のダミーを用意して、最後にダミーの次ノードを返せば`head`が削除されても対応できる。
- 重複を見つけたら最後まで消し切ろうと考えた

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        before_head = ListNode(None, head)
        prev = before_head
        
        while head and head.next:
            if head.val == head.next.val:
                while head.next and head.val == head.next.val:
                    head = head.next
                prev.next = head.next
            else:
                prev = prev.next
            head = head.next
        return before_head.next
```

## second step

- if文の後のブロックが長くなっているので関数にした
- 教えてもらったコードの整形法が役に立った

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:

        def skip_duplicates(start):
            while start.next and start.val == start.next.val:
                start = start.next
            return start.next

        before_head = ListNode(None, head)
        prev = before_head
        
        while head and head.next:
            if head.val == head.next.val:
                head = skip_duplicates(head)
                prev.next = head
            else:
                prev = prev.next
                head = head.next
        return before_head.next
```

## third step

- 4名のコードを読んだ
- 最初に重複でない場合の処理をしておくと、読む負荷が下がる
	- 前までは「重」→「軽」だったが、今は「軽」→「重』
- 1 step目で考えていた重複値を変数に保存するやり方も試したかった
- 個人的には重複があった時に、1個づつ削除するよりも一気に重複ノード達を削除する方が好き
- だから`head.next = head.next.next`よりも`head = head.next`を選択した


```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode()
        dummy.next = head
        prev = dummy

        while head and head.next:
            if head.val != head.next.val:
                prev = prev.next
                head = head.next
                continue
            duplicate_value = head.val
            while head and head.val == duplicate_value:
                head = head.next
            prev.next = head
        return dummy.next
```

### 読んだコード

- https://discord.com/channels/1084280443945353267/1195700948786491403/1196701558382018590

一番参考になったコード。実際に日本語でやり方を説明するとしたらどのように伝えるのか考えた。自由自在にコードを変形できるようになりたい。

- https://github.com/rinost081/LeetCode/pull/6/files

このコードもどうしたらわかりやすく伝えられるか考える勉強になった。フラグを使う方法もしった。

- https://github.com/h1rosaka/arai60/pull/6

新たなリストを作るやり方は思いつかなかった。重複値がないノードのみを新たなノードに繋げている。
しかし「内側のループ」→「外側のループ内の最後の文」→「else文」の流れは辿りずらいと感じた。

- https://github.com/lilnoahhh/leetcode/pull/4
