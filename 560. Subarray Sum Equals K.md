## First step

- ありうる限りのsubarrayを求めて、その合計値が`k`ならカウントを増やす。時間計算量は$O(N^2)$になるので、この入力のサイズだと時間オーバーになる。
- sliding windowみたいな方法を試したが、マイナスの値がネックだった。

(時間切れ）
```c
int subarraySum(int* nums, int numsSize, int k) {
    int start;
    int end;
    int count;
    int sum_so_far;

    count = 0;
    for (start = 0; start < numsSize; start++) {
        sum_so_far = 0;
        for (end = start; end < numsSize; end++) {
            sum_so_far += nums[end];
            if (sum_so_far == k)
                count++;
        }
    }
    return count;
}
```

- 累積和の解法を見た。初見では理解しづらかったが、図などを書いたらなんとなくわかるようになった。

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        count = 0
        sum_so_far = 0
        sum_so_far_to_count = {0: 1}

        for num in nums:
            sum_so_far += num
            need_to_remove = sum_so_far - k
            count += sum_so_far_to_count.get(need_to_remove, 0)
            sum_so_far_to_count[sum_so_far] = 1 + sum_so_far_to_count.get(sum_so_far, 0)
        return count
```

## Second step

- 累積合計値と`k`との差を表す変数名の命名に悩んだ。そもそも変数にしなくてもいいかもしれない。
- `sum_so_far_to_count`も気になった。`sum_so_far`だと、「現時点で最新の合計値」みたいな感じがする。

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        count = 0
        sum_so_far = 0
        prefix_sum_to_count = {0: 1}

        for num in nums:
            sum_so_far += num
            amount_to_subtract = sum_so_far - k
            if amount_to_subtract in prefix_sum_to_count:
                count += prefix_sum_to_count[amount_to_subtract]
            prefix_sum_to_count[sum_so_far] = 1 + prefix_sum_to_count.get(sum_so_far, 0)
        return count
```

## 振り返り

- `defaultdict`を使ったほうがスッキリする。
- `sum_so_far`も`prefix_sum`にして、辞書と統一したほうが関係が明らかになる。
- あまり解放には多様性がなかった気がする。
- コメントで補足を書いておくと、より理解しやすくなると思う。

## Third step

- `prefix_sum_to_count[0] = 1`にコメントがあればわかりやすくなると思ったが、いいコメントが思いつかなかった。
- まだよく理解できてないところがあるからか。

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        subarray_count = 0
        prefix_sum_to_count = defaultdict(int)
        prefix_sum_to_count[0] = 1  # Initial prefix sum is 0
        prefix_sum = 0

        for num in nums:
            prefix_sum += num
            subarray_count += prefix_sum_to_count[prefix_sum - k]
            prefix_sum_to_count[prefix_sum] += 1
        return subarray_count
```
