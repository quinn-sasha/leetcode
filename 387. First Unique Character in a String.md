## First step

- 重複しているかいないか、出現位置を知りたいので、辞書を使う問題だと思った。
- Pythonの辞書は、挿入順に要素が並んでいる。
- 挿入順に並んでいない場合、その中で一番若い出現位置を求めればいい。

```python
class Solution:
    def firstUniqChar(self, string: str) -> int:
        char_to_count_and_index = {}
        
        for index, char in enumerate(string):
            if char not in char_to_count_and_index:
                char_to_count_and_index[char] = [1, index]
                continue
            char_to_count_and_index[char][0] += 1
        
        for count, index in char_to_count_and_index.values():
            # dict is in insertion order
            if count == 1:
                return index
        return -1
```


## Second step

- 現時点では、初回で書いたコードのままでいい気がする。

```python
class Solution:
    def firstUniqChar(self, string: str) -> int:
        char_to_count_and_index = {}
        
        for index, char in enumerate(string):
            if char not in char_to_count_and_index:
                char_to_count_and_index[char] = [1, index]
                continue
            char_to_count_and_index[char][0] += 1
        
        for count, index in char_to_count_and_index.values():
            if count == 1:
                return index
        return -1
```


## 振り返り

- 利用したデータ構造は、解決する問題に対して必要以上に複雑になっていた。データ構造：{key -> [count, index]}
- Pythonの辞書が挿入順であることに依存している解法だった。言語間の差異を気にすると、一番小さい添字を計算するべきだと思った。
- 辞書の値に、出現位置を保存する必要はなかった。後で入力の文字列を走査すればわかることだった。
- 異なるデータ構造が、思ったよりもたくさんあった。
- LRU cacheというアルゴリズムも使われていた。
- 添字で`-1`はあり得ない数だから、見つからなかった時に、`-1`を返す意図は十分わかると思った。
- 下のコードはif-else文の方が自然だと思った。

```python
            if char not in char_to_count_and_index:
                char_to_count_and_index[char] = [1, index]
                continue
            char_to_count_and_index[char][0] += 1
```


## Third step

- 辞書を使った解法で気に入ったもの。
- 辞書でなく、セットに重複した文字を入れて処理する。辞書のみでもいけるが、重複した文字の値を入力文字列ではありえない添字にする必要がある。

```python
class Solution:
    def firstUniqChar(self, string: str) -> int:
        unique_char_to_index = {}
        seen = set()

        for index, c in enumerate(string):
            if c in seen:
                continue
            if c in unique_char_to_index:
                del unique_char_to_index[c]
                seen.add(c)
                continue
            unique_char_to_index[c] = index
        
        if not unique_char_to_index:
            return -1  # Not found
        return min(unique_char_to_index.values())
```

- リストを使った解法。
- 辞書と異なり、小文字アルフベットにしか対応できない。
- しかし、この関数を呼び出す側が、異常な文字に対して例外処理をしていると想定した。

```python
class Solution:
    def firstUniqChar(self, string: str) -> int:
        # Input string should only contain lowercase alphabets
        num_alphabets = 26
        alphabets_count = [0] * num_alphabets

        for c in string:
            alphabets_count[ord(c) - ord('a')] += 1
        for index, c in enumerate(string):
            if alphabets_count[ord(c) - ord('a')] == 1:
                return index
        return -1  # Not found
```


## 調べたこと

- [deque document](https://docs.python.org/3/library/collections.html#collections.deque): LRUcacheの実装にDequeというデータ構造が使われていた。


 ### 次やること
 
 - [Counterが実装されているソースコード](https://github.com/python/cpython/blob/main/Lib/collections/__init__.py)を読む
-  [math.inf 正の無限大](https://docs.python.org/3/library/math.html#math.inf): 特殊な浮動小数点らしい。他は[浮動小数点](https://ja.wikipedia.org/wiki/%E6%B5%AE%E5%8B%95%E5%B0%8F%E6%95%B0%E7%82%B9%E6%95%B0)
- LRU cache algorithmを実装する。[deque document](https://docs.python.org/3/library/collections.html#collections.deque)
	- 他の人の実装例：
		- https://github.com/Mike0121/LeetCode/pull/49/files
		- https://github.com/hayashi-ay/leetcode/pull/17/files
		- https://github.com/t0hsumi/leetcode/pull/15/files
