## first step

- 数字を出現回数によってランキング付けする
- 辞書が必要かな
- Min heapのサイズを`k`にすると、出現回数の低い要素を消すことができる

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        count = {}
        top_k_nums = []

        for num in nums:
            count[num] = 1 + count.get(num, 0)
        for num, count in count.items():
            heapq.heappush(top_k_nums, [count, num])
        while len(top_k_nums) > k:
            heapq.heappop(top_k_nums)
        return [count_num[1] for count_num in top_k_nums]
```


## second step

- この時点で他の人のコードは読んでいないけど、周りの人はどうしているのだろう
-  変更点：
	-  数字と出現回数の辞書なので、`num_to_count`に改名
		-  普通にpushしてからpopするよりも効率の良い`pushpop`を採用

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        num_to_count = {}
        top_k_frequent_nums = []

        for num in nums:
            num_to_count[num] = 1 + num_to_count.get(num, 0)
        for num, count in num_to_count.items():
            if len(top_k_frequent_nums) != k:
                heapq.heappush(top_k_frequent_nums, [count, num])
            else:
                heapq.heappushpop(top_k_frequent_nums, [count, num])
        return [count_and_num[1] for count_and_num in top_k_frequent_nums]

```

## 振り返り

- `return [count_and_num[1] for count_and_num in top_k_frequent_nums]`は簡略化できる。例えば、`return [num for count, num in top_k_frequent_nums]`。
- `Counter`や`defaultdict`を使えば、辞書に存在しない要素にアクセスできる。もっとみやすくできる。
- 異常なkの値に対応するめに、例外処理をしている人もいる
- heapqモジュールの`nlargest`という関数を使う方法もある
- `Counter`のメソッドに`most_common(self, n=None)`というものがある。nにkを代入するだけでこの問題を解ける。

## third step

- ソートを使った解法。
- `Counter`を使った。ほぼ辞書と同じだが、この問題により適している。

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        num_to_frequency = Counter(nums)
        frequent_nums = [(count, num) for num, count in num_to_frequency.items()]
        frequent_nums.sort(reverse=True)
        return [num for _, num in frequent_nums[:k]]
```


- `heapq`の[nlargest](https://docs.python.org/ja/3.13/library/heapq.html#heapq.nlargest)を使った解法。
- `sorted(iterable, key=key, reverse=True)[:n]`と同じこと

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        num_to_frequency = Counter(nums)
        top_k_nums = heapq.nlargest(
            k,
            num_to_frequency.items(),
            key=lambda num_to_count: num_to_count[1]
            )
        return [num for num, count in top_k_nums]
```


- `most_common`を使った解法。
- 全て返す場合は逆順ソートを使って実装している。
- それ以外の場合は、`heapq`の`nlargest`を使っている。

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        top_k_nums = Counter(nums).most_common(k)
        return [num for num, count in top_k_nums]
```


- もう一度heap
- 数字の数がkよりも少なければ全て返せばいいことを知った。

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        num_to_frequency = Counter(nums)
        top_k_nums = []

        if len(num_to_frequency) <= k:
            return [num for num, count in num_to_frequency.items()]
        
        for num, count in num_to_frequency.items():
            if len(top_k_nums) < k:
                heapq.heappush(top_k_nums, (count, num))
            else:
                heapq.heappushpop(top_k_nums, (count, num))
        return [num for _, num in top_k_nums]
```


## 調べたこと

- Python 辞書型について[公式ドキュメント](https://docs.python.org/ja/3.13/library/stdtypes.html#mapping-types-dict)を読んだ。ハッシュマップで実装されている。キーがハッシュ可能なので、キーは変更不可（イミュータブル）なオブジェクトでないといけない。
- `Counter`や`defaultdict`には`__missing__`メソッドがあるからキーが存在しない場合に対応できる。
- quick selectの解法を見た。
