## First step

- local nameを処理して、domain nameとくっつけたものの中で、いくつ固有なアドレスがあるか数える問題だと思った。
- 辞書かセットが使えそう。
- 提出したあとで気づいたが、`str`がimmutableであることを知らなかった。セットの要素になれることで気づいた。
- 文字列がimmutableなら、`string1 += string2`は毎度新たなオブジェクトを作って`string1`という名前に紐づけているのだろうか。

```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        def get_local_name_and_length(email: str) -> str:
            local_name = ""
            i = 0

            while email[i] != "+":
                if email[i] == "@":
                    break
                if email[i] == ".":
                    i += 1
                    continue
                local_name += email[i]
                i += 1
            while email[i] != "@":
                i += 1
            return local_name, i

        unique_emails = set()
        for email in emails:
            local_name, i = get_local_name_and_length(email)
            domain_name = email[i + 1:]
            unique_emails.add(local_name + "@" + domain_name)
        return len(unique_emails)
```


## Second step

```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        def get_local_name(email: str, end: int) -> str:
            local_name = ""
            i = 0

            while i < end:
                if email[i] == "+":
                    break
                if email[i] == ".":
                    i += 1
                    continue
                local_name += email[i]
                i += 1
            return local_name

        unique_emails = set()
        for email in emails:
            i = 0
            while email[i] != "@":
                i += 1
            local_name = get_local_name(email, i)
            domain_name = email[i + 1:]
            unique_emails.add(local_name + "@" + domain_name)
        return len(unique_emails)
```


## 振り返り

- `str.split()`を使えば`@`で簡単に分割できた([split document](https://docs.python.org/3.3/library/stdtypes.html#str.split))。
- `i`使って文字列を走査するよりも、for loopを使った方がシンプルになる。
- フラグを使って、local nameとdomain nameを分岐して処理している人がいる。
- やっぱり`string += string`は不安を感じるらしい。
- 入力に`@`が一つしか入らないという前提で成り立っていた。
- `f-strings`で文字列をくっ付けている人がいる。`+=`は推奨されていないらしい。
- 正規表現も使われてる。


## Third step

- 組み込み関数を使ったから、行数が少なくなった。

```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        def normalize(email: str) -> str:
            local_name, domain_name = email.split("@", maxsplit=1)  # Raise ValueError(unpacking error) if number of @ character is not 1
            processed_local_name = local_name.split("+")[0].replace(".", "")
            return f"{processed_local_name}@{domain_name}"
        
        unique_emails = set()
        for email in emails:
            unique_emails.add(normalize(email))
        return len(unique_emails)
```

- 1文字づつ見ていく解法。
- 前の解法よりも、行われている処理の詳細がわかる。

```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        def normalize(email: str) -> str:
            processed = []
            is_domain_part = False
            ignore_rest_local = False

            for c in email:
                if is_domain_part:
                    processed.append(c)
                    continue
                if c == "@":
                    is_domain_part = True
                    processed.append(c)
                    continue
                if c == "+":
                    ignore_rest_local = True
                    continue
                if ignore_rest_local:
                    continue
                if c == ".":
                    continue
                processed.append(c)
            return "".join(processed)

        unique_emails = set()
        for email in emails:
            unique_emails.add(normalize(email))
        return len(unique_emails)
```


## 調べたこと

- [split cpython](https://github.com/python/cpython/blob/main/Objects/stringlib/split.h#L102): C言語のsplit関数に似ていた。
- [iter() document](https://docs.python.org/ja/3.13/library/functions.html#iter): for loopの実装がどうなっているか興味が湧いたので、調べた。
	- オブジェクトに`iter()`が呼び出され、`iterator`が返される。
	- その`iterator`に`next()`関数もしくは`__next__()`メソッドが呼びだされることで、要素が一つづつ取り出される。
	- 最後の要素を通り過ぎたら、`StopIteration`例外が出ておわり。
- [str.replace document](https://docs.python.org/ja/3.13/library/stdtypes.html#str.replace)
