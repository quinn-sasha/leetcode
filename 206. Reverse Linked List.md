## first step

- 反復法で解いた
- `prev_node`と`node`の2つの変数を同時に進めて、`node`が`prev_node`を指すようにしたかった。
- singly linked listがあるならdoubly liked listもあるのかも

```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev_node = None
        node = head
        
        while node:
            next_node = node.next
            node.next = prev_node
            prev_node = node
            node = next_node
        return prev_node
```

- 再帰で解いてみる。苦手意識がある再帰だが、この解法は理解できた。

```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None or head.next is None:
            return head
        
        node = head
        new_head = self.reverseList(head.next)
        if node and node.next:
            node.next.next = node
            node.next = None
        return new_head
```

- stackに分類されている問題なので、stackを使ってみる

```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        stack = []
        node = head

        while node:
            stack.append(node)
            node = node.next
        if not stack:
            return None
        new_head = stack.pop()
        reversed_node = new_head
        while stack:
            reversed_node.next = stack.pop()
            reversed_node = reversed_node.next
        reversed_node.next = None
        return new_head
```


## second step

- 再帰の解法を見直した。
- `if node and node.next`のチェックは必要ない。なぜならベースケースなら既に返されていてこの文まで到達しないから。

```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None or head.next is None:
            return head
        
        node = head
        new_head = self.reverseList(head.next)
        node.next.next = node
        node.next = None
        return new_head
```


## third step

- `node.next.next = node`だと次のノードが前のノードを指していることがわかりにくい。
- この[コメント](https://discord.com/channels/1084280443945353267/1231966485610758196/1239417493211320382)を参考にした

```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def reversed_head_and_tail(node):
            if not node:
                return None, None
            if not node.next:
                return node, node
            next_node = node.next
            node.next = None
            head, tail = reversed_head_and_tail(next_node)
            tail.next = node
            return head, node

        new_head, new_tail = reversed_head_and_tail(head)
        return new_head
```


### 感想

- 先にliked-listの問題を解いていたので、再帰の解法も理解できた。
- スタックのカテゴリーではなくてlinked-listな気がする。

### 読んだコード

- https://github.com/lilnoahhh/leetcode/pull/10
- https://github.com/yus-yus/leetcode/pull/7
- https://github.com/atomina1/Arai60_review/pull/8
- https://github.com/Hurukawa2121/leetcode/pull/7
- https://discord.com/channels/1084280443945353267/1231966485610758196/1239417493211320382
