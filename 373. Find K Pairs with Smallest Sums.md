## first step

- 全てのペアをリストに入れて、ペアの合計値を基にソートする力まかせな方法を試してみたが、あまりにも遅い。
- heapを使う方法があることはわかっていたが、リストと比べたheapの必要性が理解できなかった。

(動かない)
```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        pairs = []
        for n1 in nums1:
            for n2 in nums2:
                pairs.append([n1, n2])
        pairs.sort(key=lambda pair: pair[0] + pair[1])
        return pairs[:k]
```

- heapを使った解法。
- `nums1`と`nums2`がソートされている点がこの問題の鍵だった。

```python
from heapq import heappop, heappush


class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        k_pairs = []
        visited = set()
        min_heap = []
        
        min_heap.append((nums1[0] + nums2[0], (0, 0)))
        visited.add((0, 0))
        while k > 0 and min_heap:
            _, (i, j) = heappop(min_heap)
            k_pairs.append([nums1[i], nums2[j]])

            if i + 1 < len(nums1) and (i + 1, j) not in visited:
                heappush(min_heap, (nums1[i + 1] + nums2[j], (i + 1, j)))
                visited.add((i + 1, j))
            if j + 1 < len(nums2) and (i, j + 1) not in visited:
                heappush(min_heap, (nums1[i] + nums2[j + 1], (i, j + 1)))
                visited.add((i, j + 1))
            k -= 1
        return k_pairs
```


## 振り返り

- `visited`という変数名はグラフで使われるイメージを持つ人がいる。`seen`や`added`の方がいい気がする。
- `visited.add()`はheapに入れた時ではなくて、答えのリストに追加した時でも問題ない。コードが簡単になる。
- setを使わずに、重複なく`nums1`と`nums2`を入れていく方法もあるが、読むときに考えることが増えるので採用するか悩む。
- 2つのインデックスを追加する部分を関数にした方が見やすい。
- `min_heap`という名前はいかがだろう。
- `i`と`j`という添え字はやっぱりわかりづらい気がする。`index1`は`nums1`の添え字だと判別しやすい。
- ループの条件は`k`をカウンターとして使うよりも、答えのリストの要素が`k`個になるまで、の方が好き。

## second step

- 他の人のコードを見た上で書いた。
- `added.add()`を`pairs.append()`した後に書いたらエラーが出た。理由は以下のコードの場合、`candinates`に重複が含まれてしまうこと。
- 解決策はいくつかあるが、`candinates`に入れた時に`added`に入れることを選択した。
- 変数名は`added`よりも`seen`の方が適切になった気がする。

```python
from heapq import heappop, heappush


class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        added = set()
        candinates = [(nums1[0] + nums2[0], 0, 0)]

        def add_into_candinates_if_possible(index1, index2):
            if index1 >= len(nums1) or index2 >= len(nums2):
                return
            if (index1, index2) in added:
                return
            total = nums1[index1] + nums2[index2]
            heappush(candinates, (total, index1, index2))
            added.add((index1, index2))
        
        pairs = [] 
        while len(pairs) < k and candinates:
            _, index1, index2 = heappop(candinates)
            pairs.append([nums1[index1], nums2[index2]])
            add_into_candinates_if_possible(index1 + 1, index2)
            add_into_candinates_if_possible(index1, index2 + 1)
        return pairs
```


## third step

- `added`から`seen`に改名した。
- i, jの方がこの場合見やすいと思った。

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        candinates = [(nums1[0] + nums2[0], 0, 0)]
        seen = set()

        def add_into_candinates_if_possible(i, j):
            if i >= len(nums1) or j >= len(nums2):
                return
            if (i, j) in seen:
                return
            heappush(candinates, (nums1[i] + nums2[j], i, j))
            seen.add((i, j))

        pairs = []
        while len(pairs) < k and candinates:
            _, i, j = heappop(candinates)
            pairs.append([nums1[i], nums2[j]])
            add_into_candinates_if_possible(i + 1, j)
            add_into_candinates_if_possible(i, j + 1)
        return pairs
```


## 4th step

- 日をあけて解き直したが、third stepと全く同じコードになった。

```python
from heapq import heappush, heappop


class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        candinates = [(nums1[0] + nums2[0], 0, 0)]
        seen = set()

        def add_into_candinates_if_possible(x, y):
            if x >= len(nums1) or y >= len(nums2):
                return
            if (x, y) in seen:
                return
            heappush(candinates, (nums1[x] + nums2[y], x, y))
            seen.add((x, y))
        
        pairs = []
        while len(pairs) < k and candinates:
            _, i, j = heappop(candinates)
            pairs.append([nums1[i], nums2[j]])
            add_into_candinates_if_possible(i + 1, j)
            add_into_candinates_if_possible(i, j + 1)
        return pairs
```
