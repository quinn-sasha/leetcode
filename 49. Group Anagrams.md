## first step

- anagramの条件は、辞書内の各文字のカウントが同じであること。
- `index -> 各文字列のカウンタ`の辞書を使おうとしたが、どうやって同じ値を持つindexをグループ化するかわからない。
- 辞書のキーをリストなどミュータブルなオブジェクトにできないとこで詰まった。


- anagramな文字列をソートすると、全て同じ文字列になる。
- その文字列を変数かタプルなどイミュータブルなものに変換して、キーとしてグループ化していく。

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        groups = defaultdict(list)
        
        for word in strs:
            groups[tuple(sorted(word))].append(word)
        return [group for group in groups.values()]
```

- `return groups.values()`としたら、期待されている出力と異なるタイプだと言われたので、ドキュメントを調べた。
- 返していたデータタイプは、[ビューオブジェクト](https://docs.python.org/ja/3.13/library/stdtypes.html#dictionary-view-objects)だったらしい。`List[List[str]]`とは異なることがわかった。

## second step

- `list()`で簡単に出力をリスト化できた。

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        groups = defaultdict(list)

        for word in strs:
            groups[tuple(sorted(word))].append(word)
        return list(groups.values())
```

## 振り返り

- 入力文字列に英語の小文字アルファベットしか来ないことを知った。
 - [string.ascii_lowercase](https://docs.python.org/3/library/string.html#string.ascii_lowercase)は英語の小文字アルファベットの文字列を返す。これを利用してアルファベットだけをカウントできる。
 - 異常な文字がきたら、エラーを出すべきだと思った。
- 自分はキーにtupleを使用したが、変数にソートされた文字列を入れる、または`frozenset`という変更できないsetなども選択肢にある。
- [連長圧縮](https://ja.wikipedia.org/wiki/%E9%80%A3%E9%95%B7%E5%9C%A7%E7%B8%AE)というアルゴリズムを連想する人がいる。
- 辞書名は`groups`にしたが、A_to_Bみたいにキーと値を表している変数名の方が選ばれているようだ。
- tupleもjoinもメモリ割り当ては一回で済んでる的な話は、cpythonのソースコードを読んでもよくわからなかった。


## third step

- カウントする方法で試しに解いてみた。
- 英語の小文字であるかないかのチェック方法で悩んだ。
- 小文字アルファベットのコード範囲でも条件式にできる。
- しかし`string.ascii_lowercase`の方が、より安全性が高いと思った。

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        def count_lowercase_alphabet(s: str) -> tuple:
            nalphabet = 26
            count = [0] * nalphabet
            for char in s:
                if char not in string.ascii_lowercase:
                    raise ValueError("String contains non lowercase alphabet character")
                count[ord(char) - ord('a')] += 1
            return tuple(count)

        count_to_anagram = defaultdict(list)
        for word in strs:
            count = count_lowercase_alphabet(word)
            count_to_anagram[count].append(word)
        return list(count_to_anagram.values())
```

- もう一度ソートの解法
- 組み込み関数を使いすぎている。知らない人にとってはわからないかもしれない。

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        sorted_to_anagram = defaultdict(list)

        for word in strs:
            sorted_to_anagram[tuple(sorted(word))].append(word)
        return list(sorted_to_anagram.values())
```


## 4th step(解き直し）

```python
class Solution:
    def groupAnagrams(self, words: List[str]) -> List[List[str]]:
        sorted_to_originals = defaultdict(list)

        for word in words:
            sorted_to_originals[tuple(sorted(word))].append(word)
        return list(sorted_to_originals.values())
```


## 他に調べたこと

- [ord関数](https://docs.python.org/3/library/functions.html#ord)
- [frozenset](https://docs.python.org/3/library/stdtypes.html#frozenset)
- `str`と`"".join()`の違い


  defaultdictの再実装

```python  
class DefaultDict:
    def __init__(self, default_factory=None):
        self.default_factory = default_factory
        self.original_dict = dict()

    def __setitem__(self, key, value):
        self.original_dict[key] = value

    def __getitem__(self, key):
        if key not in self.original_dict:
            self.original_dict[key] = self.default_factory()
        return self.original_dict[key]
  ```
