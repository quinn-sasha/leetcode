## First step

- heapの基本的な操作は事前時に見ておいた。
- max heqpを作り、`max_heap[k - 1]`としたかったができなかった。
- どうやってheapの性質が保たれるかは知らないので、今後の課題にする。
- 答えを見て、サイズkのmin heapでもできると知った。

```python
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.min_heap = []
        for score in nums:
            heapq.heappush(self.min_heap, score)
        while len(self.min_heap) > k:
            heapq.heappop(self.min_heap)

    def add(self, val: int) -> int:
        heapq.heappush(self.min_heap, val)
        if len(self.min_heap) > self.k:
            heapq.heappop(self.min_heap)
        return self.min_heap[0]
```

## Second step

- `heqpify`メソッドで同じことができる

```python
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.min_heap = nums
        heapq.heapify(self.min_heap)
        while len(self.min_heap) > self.k:
            heapq.heappop(self.min_heap)

    def add(self, val: int) -> int:
        heapq.heappush(self.min_heap, val)
        if len(self.min_heap) > self.k:
            heapq.heappop(self.min_heap)
        return self.min_heap[0]
```

### 振り返り

- `self.add`をコンストラクタ内で呼び出すこともできる
- `min_heap`という変数名に、サイズ`k`要素がない。一般的すぎるかも。
- `min_heap`に`nums`のコピーをとってから`heapify`しているのは良かった
- 配列をソートする、もしくはquickselectを使用した解法もある
- `0 < k <= len(nums)`でない時のエラーハンドリングがない。最小値を返している。


## Third step

```python
import heapq


class KthLargest:

    def __init__(self, k: int, test_scores: List[int]):
        self.k = k
        self.top_k_scores = []
        
        if not 0 <= k <= len(test_scores):
            raise ValueError(f'Invalid input k: {k}')

        for score in test_scores:
            self.add(score)

    def add(self, val: int) -> int:
        heapq.heappush(self.top_k_scores,)
        if len(self.top_k_scores) > self.k:
            heapq.heappop(self.top_k_scores)
        return self.top_k_scores[0]
```


## Heap実装

- Max heap(binary heap)を実装しました
- Reference:
    - https://github.com/python/cpython/blob/a8e93d3dca086896e668b88b6c5450eaf644c0e7/Lib/heapq.py#L207
    - https://github.com/hayashi-ay/leetcode/pull/54/files
 
```python
class MaxHeap:
    def __init__(self, items=None):
        if items is None:
            self.heap = []
        else:
            self.heap = items[:]  # copy items
            for i in reversed(range(len(items) // 2)):
                self._siftup(i)

    def push(self, item):
        """
        Add item into heap.
        """
        self.heap.append(item)
        self._siftdown(len(self.heap) - 1)

    def pop(self):
        """
        Pop item form heap.
        """
        if len(self.heap) <= 1:
            return self.heap.pop()  # Raise IndexError if heap is empty
        return_item = self.heap[0]
        last_ele = self.heap.pop()
        self.heap[0] = last_ele
        self._siftup(0)
        return return_item

    def peek(self):
        return self.heap[0]  # Raise IndexError if heap is empty

    def pushpop(self, item):
        """
        Faster version of push followed by pop
        """
        if self.heap and self.heap[0] > item:
            self.heap[0], item = item, self.heap[0]
            self._siftup(0)
        return item

    def replace(self, item):
        """
        Faster version of pop followed by push
        """
        return_item = self.heap[0]  # Raise IndexError if heap is empty
        self.heap[0] = item
        self._siftup(0)
        return return_item

    def _siftdown(self, pos):
        """
        Follow the path to the root,
        move parent down if parent is smaller than child
        """
        while pos > 0:
            parent_pos = (pos - 1) >> 1
            if self.heap[pos] > self.heap[parent_pos]:  # Min heap: if A < B
                self._swap_item(pos, parent_pos)
                pos = parent_pos
                continue
            break

    def _siftup(self, pos):
        """
        Bubble child up if child is bigger than parent
        """
        def get_bigger_child_pos(left_pos, right_pos):
            if self.heap[left_pos] >= self.heap[right_pos]:
                return left_pos
            else:
                return right_pos

        end_pos = len(self.heap)
        child_pos = 2 * pos + 1  # Left child

        while child_pos < end_pos:
            right_pos = 2 * pos + 2
            if right_pos < end_pos:
                child_pos = get_bigger_child_pos(child_pos, right_pos)
            if self.heap[child_pos] > self.heap[pos]:  # Min heap: if A < B
                self._swap_item(pos, child_pos)
                pos = child_pos
                child_pos = 2 * pos + 1
                continue
            break

    def _swap_item(self, pos1, pos2):
        self.heap[pos1], self.heap[pos2] = self.heap[pos2], self.heap[pos1]
```


## Step 4

- 時間を空けて解き直した。

```python
from heapq import heappush, heappushpop


class KthLargest:

    def __init__(self, k: int, scores: List[int]):
        self.k = k
        self.topk_scores = []
        
        for score in scores:
            self.add(score)

    def add(self, score: int) -> int:
        if len(self.topk_scores) < self.k:
            heappush(self.topk_scores, score)
        else:
            heappushpop(self.topk_scores, score)
        return self.topk_scores[0]
```

