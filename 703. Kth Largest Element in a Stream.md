## First step

- heapの基本的な操作は事前時に見ておいた。
- max heqpを作り、`max_heap[k - 1]`としたかったができなかった。
- どうやってheapの性質が保たれるかは知らないので、今後の課題にする。
- 答えを見て、サイズkのmin heapでもできると知った。

```python
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.min_heap = []
        for score in nums:
            heapq.heappush(self.min_heap, score)
        while len(self.min_heap) > k:
            heapq.heappop(self.min_heap)

    def add(self, val: int) -> int:
        heapq.heappush(self.min_heap, val)
        if len(self.min_heap) > self.k:
            heapq.heappop(self.min_heap)
        return self.min_heap[0]
```

## Second step

- `heqpify`メソッドで同じことができる

```python
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.min_heap = nums
        heapq.heapify(self.min_heap)
        while len(self.min_heap) > self.k:
            heapq.heappop(self.min_heap)

    def add(self, val: int) -> int:
        heapq.heappush(self.min_heap, val)
        if len(self.min_heap) > self.k:
            heapq.heappop(self.min_heap)
        return self.min_heap[0]
```

### 振り返り

- `self.add`をコンストラクタ内で呼び出すこともできる
- `min_heap`という変数名に、サイズ`k`要素がない。一般的すぎるかも。
- `min_heap`に`nums`のコピーをとってから`heapify`しているのは良かった
- 配列をソートする、もしくはquickselectを使用した解法もある
- `0 < k <= len(nums)`でない時のエラーハンドリングがない。最小値を返している。


## Third step

```python
import heapq


class KthLargest:

    def __init__(self, k: int, test_scores: List[int]):
        self.k = k
        self.top_k_scores = []
        
        if not 0 <= k <= len(test_scores):
            raise ValueError(f'Invalid input k: {k}')

        for score in test_scores:
            self.add(score)

    def add(self, val: int) -> int:
        heapq.heappush(self.top_k_scores,)
        if len(self.top_k_scores) > self.k:
            heapq.heappop(self.top_k_scores)
        return self.top_k_scores[0]
```


## 次やること

- heapとpriority queueの違いについて調べる
- 本のデータ構造の章を読む
- heapを再実装する
